<h1>Napkin DSL + Code generation</h1>

<h3>Version 0.03 - poc / demonstration / alpha</h3>

<p>Human readable custom made syntax + code generation using project-custom string templates. Using Node and Npm packages. Most importantly PEGjs for parser generation. </p>

<p>Grunt runs the parser + generator and starts watching for changes of .txt files.</p>

<p>The sample.txt contains:</p>

<pre><code>Acme
        Project
                Id key
                        "Identity"
                Name
                        "Name of project"
                        "Helptext"
                Address
                        "Full address"
                        "Street 123"
                City
</code></pre>

<p>Which parses to a json, and from there generates one cs and one html, based on easy to customise templates, to for example:</p>

<pre><code>namespace Acme {        
    public class Project { 
        [DisplayName("Identity")]
        public int Id {get;set;}
        [DisplayName("Name of project")]
        [DisplayHelp("Helptext")]
        public string Name {get;set;}
        [DisplayName("Full address")]
        [DisplayHelp("Street 123")]
        public string Address {get;set;}
        public string City {get;set;}
    }                   
</code></pre>

<p>Article + video : <a href="http://joeriks.com/2014/01/14/a-simple-dsl-code-generation-using-node/">http://joeriks.com/2014/01/14/a-simple-dsl-code-generation-using-node/</a></p>

<h2>Reasons</h2>

<p>1) to keep the domain type specifications above everything else, dependent on nothing</p>

<p>2) to be able to easily communicate the specifications with the domain knowers (my clients) in a human understandable – and not cluttered – language</p>

<p>3) to be able to use the code to generate necessary types and code in whatever syntax necessary; C#, Typescript and Javascript for example</p>

<p>4) to make it possible for easy iterations of “top-level changes” – for me or the business persons themselves to see the results of adding and changing details immediately. Without involving the ordinary developer process.</p>

<h2>Napkin Syntax</h2>

<h3>Version 0.03</h3>

<p>Write text with tab indentations to create a object tree with nodes and children.</p>

<pre><code>Node1
    ChildNode11
    ChildNode12
        GrandChildNode121
        GrandChildNode122
</code></pre>

<p>Which outputs to a json like this:</p>

<pre><code>[{
    node:"Node1",
    children: [
        {node:"ChildNode11"},
        {node:"ChildNode12",
        children:[
            {node:"GrandChildNode121"},
            {node:"GrandChildNode122"}]}]
}]
</code></pre>

<p>Node names can be literals or strings</p>

<pre><code>Node1
    "Child Node 1"
    "Child Node 2"
</code></pre>

<p>Add text in columns to add attributes.</p>

<pre><code>Node
    ChildNode Attribute1 Attribute2
</code></pre>

<p>Result:</p>

<pre><code>[{
    node:"Node",
    children: [
        {node:"ChildNode",
        attributes:[
            {"attr":"Attribute1"},
            {"attr":"Attribute2"}]}]
}]
</code></pre>

<p>Use equal sign to name attributes</p>

<pre><code>Node
    ChildNode Name=Attribute1 Color=Attribute2

[{
    node:"Node",
    children: [
        {node:"ChildNode",
        attributes:[
            {"Name":"Attribute1"},
            {"Color":"Attribute2"}]}]
}]
</code></pre>

<p>Attributes can also be strings</p>

<pre><code>Node
    ChildNode Name="Foo Bar"
</code></pre>

<p>For comments use /* */</p>

<p>You can add commands to your code</p>

<p>Include (and parse) another file. Result will be put on top of the existing file.</p>

<pre><code>/include "main.txt"
</code></pre>

<p>Map the result through a javascript file.</p>

<pre><code>/map "samplemap.js"
</code></pre>

<p>The syntax for the map file is </p>

<pre><code>module.exports = function(model) { /* do something */ return model; }
</code></pre>

<h2>Generator Syntax</h2>

<pre><code>var r = require("./generator");
var parsedResult = r("somefile.txt");
r({infile:"somefile.txt",template:"sometemplate.swig",out:"result.cs"});

// saving parsed json
r({infile:"somefile.txt",resultout:"somefile.json"});

//define parser (js file)
r({parser:"parser", infile:"somefile.txt"});
</code></pre>